# Architecture Guide: VSCode Automation System

## 1. Core Philosophy: A Stable Client-Server Model

This system is designed based on a **strict client-server architecture** to ensure stability, scalability, and clear separation of concerns.

-   **The Server (VSCode Extension):** The VSCode instance, managed by `VSCodeProcessManager`, acts as a **stateful, singleton server**. It is launched once and remains active to serve multiple requests. Its sole purpose is to provide a stable interface to the VSCode API.
-   **The Client (Python Scripts):** Any external script (e.g., `simple_continuous_executor.py`) acts as a **client**. The client is responsible for orchestrating the overall workflow, managing business logic, and communicating with the server to perform VSCode-specific actions.

This model prevents the high overhead of launching a new VSCode process for each task and ensures that the extension's state is preserved across operations.

---

## 2. Component Responsibilities

### 2.1. VSCode Extension (Server-Side)

The extension's responsibilities are strictly limited to interacting with the VSCode API. It should be treated as a thin, stable wrapper.

**MUST:**
-   **Expose a Command-Based API:** Listen for commands via a file-based IPC mechanism.
-   **Interact with VSCode Internals:** Execute tasks using `vscode.window`, `vscode.commands`, `vscode.lm`, etc.
-   **Return Actionable Results:** Report back the `success` or `error` status of a command, along with any relevant data (e.g., text generated by Copilot) or error messages.
-   **Be Stateless (at the command level):** Each command should be atomic and self-contained. The extension should not retain memory of previous commands.

**MUST NOT:**
-   **Contain Business Logic:** Do not implement complex workflows, loops, or decision-making.
-   **Manage its Own Lifecycle:** The extension should not attempt to quit or restart itself. This is the client's responsibility.
-   **Interact with External Systems:** Do not directly access databases, external APIs, or the file system outside of its designated IPC directories.

### 2.2. Python Client (Client-Side)

The client is the "brain" of the operation. It holds all the business logic and orchestrates the entire process.

**MUST:**
-   **Manage the VSCode Lifecycle:** Use `VSCodeProcessManager` to ensure the singleton server is running.
-   **Orchestrate the Workflow:** Read instructions, loop through tasks, and decide what to do next.
-   **Construct and Send IPC Requests:** Create well-formed JSON request files and place them in the `requests` directory.
-   **Handle IPC Responses:** Poll the `responses` directory, parse the JSON response, and handle timeouts.
-   **Implement All Error Handling:** Manage retries, cold-start delays, and recovery from failed operations.
-   **Process and Store Data:** Connect to databases, generate reports, and perform any data transformation.

**MUST NOT:**
-   **Attempt Direct UI Interaction:** Do not use GUI automation tools to interact with the VSCode window. Rely solely on the IPC mechanism.

---

## 3. IPC Protocol Specification

Communication is asynchronous and file-based to ensure loose coupling.

-   **Transport:** Two directories, `/tmp/copilot-evaluation/requests` and `/tmp/copilot-evaluation/responses`.
-   **Request (`requests/{request_id}.json`):**
    ```json
    {
      "request_id": "unique-identifier-string",
      "command": "nameOfCommandToExecute",
      "params": { ... }
    }
    ```
-   **Response (`responses/{request_id}.json`):**
    ```json
    // On Success
    {
      "request_id": "unique-identifier-string",
      "status": "success",
      "data": { ... } // Command-specific return value
    }

    // On Error
    {
      "request_id": "unique-identifier-string",
      "status": "error",
      "error_message": "A descriptive error message."
    }
    ```
-   **Lifecycle:**
    1.  Client creates the request file.
    2.  Extension detects, processes, and then **deletes** the request file.
    3.  Extension creates the response file.
    4.  Client detects, processes, and then **deletes** the response file.

This lifecycle ensures that files do not accumulate and provides a clear, atomic signal for request completion.
