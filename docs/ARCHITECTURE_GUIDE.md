# Architecture Guide: VSCode Automation System

## 1. Core Philosophy: A Stable Client-Server Model

This system is designed based on a **strict client-server architecture** to ensure stability, scalability, and clear separation of concerns.

- **The Server (VSCode Extension):** The VSCode instance, managed by `VSCodeProcessManager`, acts as a **stateful, singleton server**. It is launched once and remains active to serve multiple requests. Its sole purpose is to provide a stable interface to the VSCode API.
- **The Client (Python Scripts):** Any external script (e.g., `simple_continuous_executor.py`) acts as a **client**. The client is responsible for orchestrating the overall workflow, managing business logic, and communicating with the server to perform VSCode-specific actions.

This model prevents the high overhead of launching a new VSCode process for each task and ensures that the extension's state is preserved across operations.

---

## 2. Component Responsibilities

### 2.1. VSCode Extension (Server-Side)

The extension's responsibilities are strictly limited to interacting with the VSCode API. It should be treated as a thin, stable wrapper.

**MUST:**

- **Expose a Command-Based API:** Listen for commands via a file-based IPC mechanism.
- **Interact with VSCode Internals:** Execute tasks using `vscode.window`, `vscode.commands`, `vscode.lm`, etc.
- **Return Actionable Results:** Report back the `success` or `error` status of a command, along with any relevant data (e.g., text generated by Copilot) or error messages.
- **Be Stateless (at the command level):** Each command should be atomic and self-contained. The extension should not retain memory of previous commands.

**MUST NOT:**

- **Contain Business Logic:** Do not implement complex workflows, loops, or decision-making.
- **Manage its Own Lifecycle:** The extension should not attempt to quit or restart itself. This is the client's responsibility.
- **Interact with External Systems:** Do not directly access databases, external APIs, or the file system outside of its designated IPC directories.

### 2.2. Python Client (Client-Side)

The client is the "brain" of the operation. It holds all the business logic and orchestrates the entire process.

**MUST:**

- **Manage the VSCode Lifecycle:** Use `VSCodeProcessManager` to ensure the singleton server is running.
- **Orchestrate the Workflow:** Read instructions, loop through tasks, and decide what to do next.
- **Construct and Send IPC Requests:** Create well-formed JSON request files and place them in the `requests` directory.
- **Handle IPC Responses:** Poll the `responses` directory, parse the JSON response, and handle timeouts.
- **Implement All Error Handling:** Manage retries, cold-start delays, and recovery from failed operations.
- **Process and Store Data:** Connect to databases, generate reports, and perform any data transformation.

**MUST NOT:**

- **Attempt Direct UI Interaction:** Do not use GUI automation tools to interact with the VSCode window. Rely solely on the IPC mechanism.

---

## 3. IPC Protocol Specification

Communication is asynchronous and file-based to ensure loose coupling.

### 3.1. Directory Structure

The system's operation revolves around a defined directory structure within `/tmp/copilot-evaluation/`:

- **/requests/**: Contains pending tasks for the VSCode extension. A file here represents a desired state.
- **/responses/**: Contains the latest outcome (success or error) for a given request. A file here represents the current state.
- **/failed/**: An audit log for requests that were abandoned by the client after multiple retries. The client copies the final failed response here.
- **/eval/**: Used by a separate, asynchronous process to store the results of quality evaluations on successful responses. It is **not** part of the core IPC flow.

### 3.2. Request/Response Format

- **Request (`requests/{request_id}.json`):**

    ```json
    {
      "request_id": "unique-identifier-string",
      "command": "nameOfCommandToExecute",
      "params": { ... }
    }
    ```

- **Response (`responses/{request_id}.json`):**

    ```json
    // On Success
    {
      "request_id": "unique-identifier-string",
      "status": "success",
      "data": { ... }
    }

    // On Error
    {
      "request_id": "unique-identifier-string",
      "status": "error",
      "error_message": "A descriptive error message."
    }
    ```

### 3.3. IPC Interaction Flow & Example

The client's primary goal is to ensure every request in the `requests` directory eventually has a corresponding successful response. The files themselves are persistent records.

**Lifecycle of `request-123`:**

1. **Initial State:** The client submits a new request.

    ```
    /tmp/copilot-evaluation/
    └── requests/
        └── request-123.json
    ```

2. **Attempt 1 Fails (Error Response):** The server responds with an error.

    ```
    /tmp/copilot-evaluation/
    ├── requests/
    │   └── request-123.json
    └── responses/
        └── request-123.json  (contains "status": "error")
    ```

    The client reads this, **deletes `responses/request-123.json`**, and prepares to retry.

3. **Attempt 2 Succeeds:** The server processes the request correctly.

    ```
    /tmp/copilot-evaluation/
    ├── requests/
    │   └── request-123.json
    └── responses/
        └── request-123.json  (contains "status": "success")
    ```

    The client sees the success response and considers the task done. **No files are moved or deleted.** The final state is preserved as a record.

4. **Alternative (Terminal Failure):** If a request fails 3 times, the client gives up.

    ```
    /tmp/copilot-evaluation/
    ├── requests/
    │   └── request-123.json
    ├── responses/
    │   └── request-123.json  (the final error response)
    └── failed/
        └── request-123.json  (a copy of the final failed response)
    ```

    The client **copies** the last response to `failed/` and stops tracking `request-123`. The original files remain.

---

## 4. Client-Side State Management

The robustness of this system relies on the client's ability to manage the state of each request internally.

### 4.1. Core Principle: Client Owns the State

The file system reflects the desired state (`requests`) and the latest outcome (`responses`), but the client is responsible for tracking retry counts and terminal failures to drive the process.

### 4.2. Recommended Implementation

A client should maintain an in-memory dictionary or state machine that maps each `request_id` to its current status, such as:

- `NEW`
- `POLLING (attempt: 1)`
- `POLLING (attempt: 2)`
- `POLLING (attempt: 3)`
- `SUCCESS`
- `GAVE_UP`

This prevents infinite loops and ensures each request is handled according to the defined logic, even if the client process is restarted.

### 4.3. VSCode Cold Start (Proactive Prevention)

- **Problem:** Upon initial launch, the VSCode extension may be active but not fully initialized, leading to initial requests failing.
- **Strategy:** As per memory `cdb228f2-9a13-4997-94f8-112b3b450cb4`, the client **must** implement a proactive delay.
  - After `VSCodeProcessManager` confirms VSCode is running, the client should **wait for a fixed period (e.g., 20 seconds)** before sending the first request.
  - This is not an error condition, but a mandatory step in the client's startup logic to ensure system reliability.
